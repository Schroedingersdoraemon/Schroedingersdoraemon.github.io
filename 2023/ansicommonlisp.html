<!doctype html><title>
ANSI.Common.Lisp
    </title><meta charset=utf-8><meta content=width=device-width initial-scale=1 name=viewport><link href=/theme/css/main.css rel=stylesheet><body><h1>ANSI.Common.Lisp</h1> 2023-06-14 20:35 <hr><div class="contents topic" id=topic-1><p class=topic-title><a class="reference internal" href=#top>目录</a><ul class=simple><li><a class="reference internal" href=#introduction id=toc-entry-1>1. Introduction</a><ul><li><a class="reference internal" href=#new-tools id=toc-entry-2>1.1. New Tools</a><li><a class="reference internal" href=#new-techniques id=toc-entry-3>1.2. New Techniques</a><li><a class="reference internal" href=#a-new-approach id=toc-entry-4>1.3. A New Approach</a></ul><li><a class="reference internal" href=#welcome-to-lisp id=toc-entry-5>2. Welcome to Lisp</a><ul><li><a class="reference internal" href=#form id=toc-entry-6>2.1. form</a><li><a class="reference internal" href=#evaluation id=toc-entry-7>2.2. evaluation</a><li><a class="reference internal" href=#data id=toc-entry-8>2.3. data</a><li><a class="reference internal" href=#list-operation id=toc-entry-9>2.4. list operation</a><li><a class="reference internal" href=#truth id=toc-entry-10>2.5. truth</a><li><a class="reference internal" href=#functions id=toc-entry-11>2.6. functions</a><li><a class="reference internal" href=#recursion id=toc-entry-12>2.7. recursion</a><li><a class="reference internal" href=#reading-lisp id=toc-entry-13>2.8. reading lisp</a><li><a class="reference internal" href=#input-and-output id=toc-entry-14>2.9. input and output</a><li><a class="reference internal" href=#variables id=toc-entry-15>2.10. variables</a><li><a class="reference internal" href=#assignment id=toc-entry-16>2.11. assignment</a><li><a class="reference internal" href=#funcional-programming id=toc-entry-17>2.12. funcional programming</a><li><a class="reference internal" href=#iteration id=toc-entry-18>2.13. iteration</a><li><a class="reference internal" href=#functions-as-objects id=toc-entry-19>2.14. functions as objects</a><li><a class="reference internal" href=#types id=toc-entry-20>2.15. types</a><li><a class="reference internal" href=#looking-forward id=toc-entry-21>2.16. looking forward</a><li><a class="reference internal" href=#exercise id=toc-entry-22>2.17. exercise</a></ul><li><a class="reference internal" href=#lists id=toc-entry-23>3. Lists</a><ul><li><a class="reference internal" href=#conses id=toc-entry-24>3.1. conses</a><li><a class="reference internal" href=#equality id=toc-entry-25>3.2. equality</a></ul></ul></div><div class=section id=introduction><h2><a class=toc-backref href=#toc-entry-1>1. Introduction</a></h2><p>John McCarthy, 1958<p>designed to evolve<p>This introduction may seem a collection of grand and possibily meaningless claims.<div class=section id=new-tools><h3><a class=toc-backref href=#toc-entry-2>1.1. New Tools</a></h3><p>Reward: you will feel as suffocated programming in C++ as an experienced C++ programmer would feel programming in Basic.</div><div class=section id=new-techniques><h3><a class=toc-backref href=#toc-entry-3>1.2. New Techniques</a></h3><p>extensible, reusable, rapid prototyping</div><div class=section id=a-new-approach><h3><a class=toc-backref href=#toc-entry-4>1.3. A New Approach</a></h3><ul class=simple><li>interactive environments<li>garbage collection<li>run-time typing<li>...</ul></div></div><div class=section id=welcome-to-lisp><h2><a class=toc-backref href=#toc-entry-5>2. Welcome to Lisp</a></h2><div class=section id=form><h3><a class=toc-backref href=#toc-entry-6>2.1. form</a></h3><dl class=docutils><dt><em>toplevel</em><dd>interactive front-end</dl><p>(+ 2 3) prefix notation<p>(operator argument1, argument2, ...)</div><div class=section id=evaluation><h3><a class=toc-backref href=#toc-entry-7>2.2. evaluation</a></h3><p>when lisp evaluates a function call like (+ 2 3)<ul class=simple><li>arguments are evaluated, from left to right<li>arguments are passed to the function named by the operator</ul><p>lisp provides the quote as a way of <em>protecting</em> expressions from evaluation<div class=highlight><pre><span></span><span class=nb>></span><span class=w> </span><span class=p>(</span><span class=k>quote</span><span class=w> </span><span class=p>(</span><span class=nb>+</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=mi>5</span><span class=p>))</span>
<span class=nb>></span><span class=w> </span><span class=o>'</span><span class=p>(</span><span class=nb>+</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=mi>5</span><span class=p>)</span>
</pre></div><p>return the singly taken argument verbatim</div><div class=section id=data><h3><a class=toc-backref href=#toc-entry-8>2.3. data</a></h3><ul class=simple><li>integer - a series of digits<li>string - characters surrounded by double-quotes<li><strong>symbols</strong> - words, ordinarily converted to uppercase. To refer it, quote it.<li><strong>lists</strong> - (<em>list</em> arg1 arg2 ...) build lists<li>empty list - () or NIL</ul></div><div class=section id=list-operation><h3><a class=toc-backref href=#toc-entry-9>2.4. list operation</a></h3><p><em>cons</em> builds lists. If its 2nd argument is a list, a new list with the 1st argument prepended to the front.<div class=highlight><pre><span></span><span class=nb>></span><span class=w> </span><span class=p>(</span><span class=nb>cons</span><span class=w> </span><span class=ss>'a</span><span class=w> </span><span class=o>'</span><span class=p>(</span><span class=nv>b</span><span class=w> </span><span class=nv>c</span><span class=w> </span><span class=nv>d</span><span class=p>))</span>
<span class=p>(</span><span class=nv>A</span><span class=w> </span><span class=nv>B</span><span class=w> </span><span class=nv>C</span><span class=w> </span><span class=nv>D</span><span class=p>)</span>
</pre></div><p><em>car</em> gets the first element, <em>cdr</em> for the rest<div class=highlight><pre><span></span><span class=nb>></span><span class=w> </span><span class=p>(</span><span class=nb>car</span><span class=w> </span><span class=o>'</span><span class=p>(</span><span class=nv>a</span><span class=w> </span><span class=nv>b</span><span class=w> </span><span class=nv>c</span><span class=p>))</span>
<span class=nv>A</span>
<span class=nb>></span><span class=w> </span><span class=p>(</span><span class=nb>cdr</span><span class=w> </span><span class=o>'</span><span class=p>(</span><span class=nv>a</span><span class=w> </span><span class=nv>b</span><span class=w> </span><span class=nv>c</span><span class=p>))</span>
<span class=p>(</span><span class=nv>B</span><span class=w> </span><span class=nv>C</span><span class=p>)</span>
</pre></div><p>For instance, to get 3rd element<div class=highlight><pre><span></span><span class=nb>></span><span class=w> </span><span class=p>(</span><span class=nb>car</span><span class=w> </span><span class=p>(</span><span class=nb>cdr</span><span class=w> </span><span class=p>(</span><span class=nb>cdr</span><span class=w> </span><span class=o>'</span><span class=p>(</span><span class=nv>a</span><span class=w> </span><span class=nv>b</span><span class=w> </span><span class=nv>c</span><span class=w> </span><span class=nv>d</span><span class=p>))))</span>
<span class=nv>C</span>
<span class=nb>></span><span class=w> </span><span class=p>(</span><span class=nb>third</span><span class=w> </span><span class=o>'</span><span class=p>(</span><span class=nv>a</span><span class=w> </span><span class=nv>b</span><span class=w> </span><span class=nv>c</span><span class=w> </span><span class=nv>d</span><span class=p>))</span>
<span class=nv>C</span>
</pre></div></div><div class=section id=truth><h3><a class=toc-backref href=#toc-entry-10>2.5. truth</a></h3><p><em>listp</em> returns true, symbol <em>t</em>, if its argument is a list<p>Common Lisp <em>predicates</em> often have names end with p.<div class=highlight><pre><span></span><span class=nb>></span><span class=w> </span><span class=p>(</span><span class=nb>null</span><span class=w> </span><span class=no>nil</span><span class=p>)</span><span class=w> </span><span class=c1>; *null* returns true of the empty list</span>
<span class=no>T</span>
<span class=nb>></span><span class=w> </span><span class=p>(</span><span class=nb>not</span><span class=w> </span><span class=no>nil</span><span class=p>)</span><span class=w> </span><span class=c1>; *not* returns true if its argument is false</span>
<span class=no>T</span>
</pre></div><p>(<em>if</em> <em>test</em> <em>then</em> <em>[else]</em>)<div class=highlight><pre><span></span><span class=nb>></span><span class=w> </span><span class=p>(</span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nb>listp</span><span class=w> </span><span class=o>'</span><span class=p>(</span><span class=nv>a</span><span class=w> </span><span class=nv>b</span><span class=w> </span><span class=nv>c</span><span class=p>))</span>
<span class=w>     </span><span class=p>(</span><span class=nb>+</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=mi>2</span><span class=p>)</span>
<span class=w>     </span><span class=p>(</span><span class=nb>+</span><span class=w> </span><span class=mi>5</span><span class=w> </span><span class=mi>6</span><span class=p>))</span>
<span class=mi>3</span>
</pre></div><p>if <em>else</em> is omitted, it defaults to <em>nil</em><div class=highlight><pre><span></span><span class=nb>></span><span class=w> </span><span class=p>(</span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nb>listp</span><span class=w> </span><span class=mi>24</span><span class=p>)</span>
<span class=w>     </span><span class=p>(</span><span class=nb>+</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=mi>4</span><span class=p>))</span>
<span class=no>NIL</span>
</pre></div><p>Everything except for <em>nil</em> represents <em>true</em>.<div class=highlight><pre><span></span><span class=nb>></span><span class=w> </span><span class=p>(</span><span class=k>if</span><span class=w> </span><span class=mi>24</span><span class=w> </span><span class=mi>4</span><span class=w> </span><span class=mi>5</span><span class=p>)</span>
<span class=mi>4</span>
</pre></div><p><em>and</em> and <em>or</em> resemble conditionals.<div class=highlight><pre><span></span><span class=nb>></span><span class=w> </span><span class=p>(</span><span class=nb>and</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=mi>3</span><span class=p>)</span><span class=w> </span><span class=c1>; and</span>
<span class=mi>3</span>

<span class=nb>></span><span class=w> </span><span class=p>(</span><span class=nb>or</span><span class=w> </span><span class=mi>4</span><span class=w> </span><span class=mi>5</span><span class=p>)</span><span class=w> </span><span class=c1>; and or are macros</span>
<span class=mi>4</span>
</pre></div></div><div class=section id=functions><h3><a class=toc-backref href=#toc-entry-11>2.6. functions</a></h3><div class=highlight><pre><span></span><span class=nb>></span><span class=w> </span><span class=p>(</span><span class=nb>defun</span><span class=w> </span><span class=nv>sum-greater</span><span class=w> </span><span class=p>(</span><span class=nv>x</span><span class=w> </span><span class=nv>y</span><span class=w> </span><span class=nv>z</span><span class=p>)</span>
<span class=w>     </span><span class=p>(</span><span class=nb>></span><span class=w> </span><span class=p>(</span><span class=nb>+</span><span class=w> </span><span class=nv>x</span><span class=w> </span><span class=nv>y</span><span class=p>)</span><span class=w> </span><span class=nv>z</span><span class=p>))</span>
<span class=nv>SUM-GREATER</span>
<span class=nb>></span><span class=w> </span><span class=p>(</span><span class=nv>sum-greater</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=mi>4</span><span class=w> </span><span class=mi>3</span><span class=p>)</span>
<span class=no>T</span>
</pre></div></div><div class=section id=recursion><h3><a class=toc-backref href=#toc-entry-12>2.7. recursion</a></h3><div class=highlight><pre><span></span><span class=nb>></span><span class=w> </span><span class=p>(</span><span class=nb>defun</span><span class=w> </span><span class=nv>my-member</span><span class=w> </span><span class=p>(</span><span class=nv>obj</span><span class=w> </span><span class=nv>lst</span><span class=p>)</span>
<span class=w>     </span><span class=p>(</span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nb>null</span><span class=w> </span><span class=nv>lst</span><span class=p>)</span>
<span class=w>     </span><span class=no>NIL</span>
<span class=w>     </span><span class=p>(</span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nb>eql</span><span class=w> </span><span class=nv>obj</span><span class=w> </span><span class=p>(</span><span class=nb>car</span><span class=w> </span><span class=nv>lst</span><span class=p>))</span>
<span class=w>     </span><span class=nv>lst</span>
<span class=w>     </span><span class=p>(</span><span class=nv>my-member</span><span class=w> </span><span class=nv>obj</span><span class=w> </span><span class=p>(</span><span class=nb>cdr</span><span class=w> </span><span class=nv>lst</span><span class=p>)))))</span>
</pre></div></div><div class=section id=reading-lisp><h3><a class=toc-backref href=#toc-entry-13>2.8. reading lisp</a></h3><p>read code by indentation, with an editor supporting matching parentheses.</div><div class=section id=input-and-output><h3><a class=toc-backref href=#toc-entry-14>2.9. input and output</a></h3><blockquote><p>(<em>format</em> arg1 arg2 args)<ul class=simple><li>arg1 - where the output is to be printed - t - output is sent to default place, toplevel<li>arg2 - string template - ~A indicates a position to be filled, ~% is a newline<li>args - to be inserted into template</ul></blockquote><div class=highlight><pre><span></span><span class=nb>></span><span class=w> </span><span class=p>(</span><span class=nb>format</span><span class=w> </span><span class=no>t</span><span class=w> </span><span class=s>"~A plus ~A equals ~A.~%"</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=p>(</span><span class=nb>+</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=mi>3</span><span class=p>))</span>
<span class=mi>2</span><span class=w> </span><span class=nv>plus</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=nv>equals</span><span class=w> </span><span class=mi>5</span>
<span class=no>NIL</span><span class=w>  </span><span class=c1>; returned by the call to format</span>
</pre></div></div><div class=section id=variables><h3><a class=toc-backref href=#toc-entry-15>2.10. variables</a></h3><p><em>set</em> allows to introduce new <em>local</em> variables<div class=highlight><pre><span></span><span class=nb>></span><span class=w> </span><span class=p>(</span><span class=k>let</span><span class=w> </span><span class=p>((</span><span class=vg>*variable*</span><span class=w> </span><span class=vg>*expression*</span><span class=p>)</span><span class=w> </span><span class=o>...</span><span class=w> </span><span class=p>)</span>
<span class=w>     </span><span class=o>...</span><span class=p>)</span>

<span class=nb>></span><span class=w> </span><span class=p>(</span><span class=nb>defun</span><span class=w> </span><span class=nv>ask-number</span><span class=p>()</span>
<span class=w>     </span><span class=p>(</span><span class=nb>format</span><span class=w> </span><span class=no>t</span><span class=w> </span><span class=s>"please enter a number"</span><span class=p>)</span>
<span class=w>     </span><span class=p>(</span><span class=k>let</span><span class=w> </span><span class=p>((</span><span class=nv>var</span><span class=w> </span><span class=p>(</span><span class=nb>read</span><span class=p>)))</span>
<span class=w>        </span><span class=p>(</span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nb>numberp</span><span class=w> </span><span class=nv>var</span><span class=p>)</span>
<span class=w>          </span><span class=nv>var</span>
<span class=w>          </span><span class=p>(</span><span class=nv>ask-number</span><span class=p>)))</span>
</pre></div><p>give a symbol and a value to <em>defparameter</em><p>or define global constants by <em>defconstant</em><div class=highlight><pre><span></span><span class=nb>></span><span class=w> </span><span class=p>(</span><span class=nb>defparameter</span><span class=w> </span><span class=vg>*glob*</span><span class=w> </span><span class=mi>99</span><span class=p>)</span>
<span class=vg>*GLOB*</span>
<span class=nb>></span><span class=w> </span><span class=p>(</span><span class=nb>defconstant</span><span class=w> </span><span class=nv>limit</span><span class=w> </span><span class=p>(</span><span class=nb>+</span><span class=w> </span><span class=vg>*glob*</span><span class=w> </span><span class=mi>1</span><span class=p>))</span>
<span class=nv>LIMIT</span>

<span class=nb>></span><span class=w> </span><span class=p>(</span><span class=nb>boundp</span><span class=w> </span><span class=ss>'*glob*</span><span class=p>)</span>
<span class=no>T</span>
</pre></div></div><div class=section id=assignment><h3><a class=toc-backref href=#toc-entry-16>2.11. assignment</a></h3><div class=highlight><pre><span></span><span class=nb>></span><span class=w> </span><span class=p>(</span><span class=nb>setf</span><span class=w> </span><span class=vg>*glob*</span><span class=w> </span><span class=mi>37</span><span class=p>)</span>
<span class=vg>*GLOB*</span>
<span class=nb>></span><span class=w> </span><span class=p>(</span><span class=k>let</span><span class=w> </span><span class=p>((</span><span class=nv>n</span><span class=w> </span><span class=mi>10</span><span class=p>))</span>
<span class=w>     </span><span class=p>(</span><span class=nb>setf</span><span class=w> </span><span class=nv>n</span><span class=w> </span><span class=mi>2</span><span class=p>)</span>
<span class=w>     </span><span class=nv>n</span><span class=p>)</span>
<span class=nb>></span><span class=w> </span><span class=p>(</span><span class=nb>setf</span><span class=w> </span><span class=nv>a</span><span class=w> </span><span class=nv>b</span>
<span class=w>        </span><span class=nv>c</span><span class=w> </span><span class=nv>d</span><span class=p>)</span><span class=w>  </span><span class=c1>; equals two assignments respectively</span>
</pre></div></div><div class=section id=funcional-programming><h3><a class=toc-backref href=#toc-entry-17>2.12. funcional programming</a></h3><p>It means writing programs that work by returning values, instead of by modifying things, which is the dominant paradigm in Lisp.<div class=highlight><pre><span></span><span class=nb>></span><span class=w> </span><span class=p>(</span><span class=nb>setf</span><span class=w> </span><span class=nv>lst</span><span class=w> </span><span class=o>'</span><span class=p>(</span><span class=nv>a</span><span class=w> </span><span class=nv>b</span><span class=w> </span><span class=nv>c</span><span class=w> </span><span class=nv>a</span><span class=w> </span><span class=nv>d</span><span class=p>))</span>
<span class=p>(</span><span class=nv>A</span><span class=w> </span><span class=nv>B</span><span class=w> </span><span class=nv>C</span><span class=w> </span><span class=nv>A</span><span class=w> </span><span class=nv>D</span><span class=p>)</span>
<span class=nb>></span><span class=w> </span><span class=p>(</span><span class=nb>remove</span><span class=w> </span><span class=ss>'a</span><span class=w> </span><span class=nv>lst</span><span class=p>)</span>
<span class=p>(</span><span class=nv>B</span><span class=w> </span><span class=nv>C</span><span class=w> </span><span class=nv>D</span><span class=p>)</span>
<span class=nb>></span><span class=w> </span><span class=p>(</span><span class=nb>setf</span><span class=w> </span><span class=nv>lst</span><span class=w> </span><span class=p>(</span><span class=nb>remove</span><span class=w> </span><span class=ss>'a</span><span class=w> </span><span class=nv>lst</span><span class=p>))</span><span class=w>  </span><span class=c1>; the original lst remains untouched</span>
<span class=p>(</span><span class=nv>B</span><span class=w> </span><span class=nv>C</span><span class=w> </span><span class=nv>D</span><span class=p>)</span>
</pre></div></div><div class=section id=iteration><h3><a class=toc-backref href=#toc-entry-18>2.13. iteration</a></h3><div class=highlight><pre><span></span><span class=nb>></span><span class=w> </span><span class=p>(</span><span class=nb>defun</span><span class=w> </span><span class=nv>show-squares</span><span class=w> </span><span class=p>(</span><span class=nv>start</span><span class=w> </span><span class=nv>end</span><span class=p>)</span>
<span class=w>     </span><span class=p>(</span><span class=nb>do</span><span class=w> </span><span class=p>((</span><span class=nv>i</span><span class=w> </span><span class=nv>start</span><span class=w> </span><span class=p>(</span><span class=nb>+</span><span class=w> </span><span class=nv>i</span><span class=w> </span><span class=mi>1</span><span class=p>)))</span><span class=w>  </span><span class=c1>; (variable initial update)</span>
<span class=w>      </span><span class=p>((</span><span class=nb>></span><span class=w> </span><span class=nv>i</span><span class=w> </span><span class=mi>10</span><span class=p>)</span><span class=w> </span><span class=ss>'done</span><span class=p>)</span><span class=w>  </span><span class=c1>; (stop criteria, expression evaluated when stop)</span>
<span class=w>      </span><span class=p>(</span><span class=nb>format</span><span class=w> </span><span class=no>t</span><span class=w> </span><span class=s>"~A ~A~%"</span><span class=w> </span><span class=nv>i</span><span class=w> </span><span class=p>(</span><span class=nb>*</span><span class=w> </span><span class=nv>i</span><span class=w> </span><span class=nv>i</span><span class=p>))))</span><span class=w>  </span><span class=c1>; body of the loop</span>

<span class=nb>></span><span class=w> </span><span class=p>(</span><span class=nv>show-squares</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=mi>4</span><span class=p>)</span>
<span class=mi>2</span><span class=w> </span><span class=mi>4</span>
<span class=mi>3</span><span class=w> </span><span class=mi>9</span>
<span class=mi>4</span><span class=w> </span><span class=mi>16</span>
<span class=nv>DONE</span>
</pre></div><div class=highlight><pre><span></span><span class=nb>></span><span class=w> </span><span class=p>(</span><span class=nb>defun</span><span class=w> </span><span class=nv>show-squares</span><span class=w> </span><span class=p>(</span><span class=nv>i</span><span class=w> </span><span class=nv>end</span><span class=p>)</span>
<span class=w>     </span><span class=p>(</span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nb>></span><span class=w> </span><span class=nv>i</span><span class=w> </span><span class=nv>end</span><span class=p>)</span>
<span class=w>         </span><span class=ss>'done</span>
<span class=w>         </span><span class=p>(</span><span class=k>progn</span><span class=w>  </span><span class=c1>; evaluates expressions in order, return the value of last</span>
<span class=w>             </span><span class=p>(</span><span class=nb>format</span><span class=w> </span><span class=no>t</span><span class=w> </span><span class=s>"~A ~A~%"</span><span class=w> </span><span class=nv>i</span><span class=w> </span><span class=p>(</span><span class=nb>*</span><span class=w> </span><span class=nv>i</span><span class=w> </span><span class=nv>i</span><span class=p>))</span>
<span class=w>             </span><span class=p>(</span><span class=nv>show-squares</span><span class=w> </span><span class=p>(</span><span class=nb>+</span><span class=w> </span><span class=nv>i</span><span class=w> </span><span class=mi>1</span><span class=p>)</span><span class=w> </span><span class=nv>end</span><span class=p>))))</span>
</pre></div><p><em>dolist</em> takes an argument of the form (<em>variable</em> <em>expression</em>), followed by a body of expressions. The body will be evaluated with <em>variable</em> bound to successive elements of the list returned by <em>expression</em><div class=highlight><pre><span></span><span class=nb>></span><span class=w> </span><span class=p>(</span><span class=nb>defun</span><span class=w> </span><span class=nv>our-length</span><span class=w> </span><span class=p>(</span><span class=nv>lst</span><span class=p>)</span>
<span class=w>     </span><span class=p>(</span><span class=k>let</span><span class=w> </span><span class=p>((</span><span class=nv>len</span><span class=w> </span><span class=mi>0</span><span class=p>))</span>
<span class=w>       </span><span class=p>(</span><span class=nb>dolist</span><span class=w> </span><span class=p>(</span><span class=nv>obj</span><span class=w> </span><span class=nv>lst</span><span class=p>)</span><span class=w>  </span><span class=c1>; (variable expression</span>
<span class=w>         </span><span class=p>(</span><span class=nb>setf</span><span class=w> </span><span class=nv>len</span><span class=w> </span><span class=p>(</span><span class=nb>+</span><span class=w> </span><span class=nv>len</span><span class=w> </span><span class=mi>1</span><span class=p>)))</span><span class=w>  </span><span class=c1>; body of expressions</span>
<span class=w>     </span><span class=nv>len</span><span class=p>))</span>
</pre></div><div class=highlight><pre><span></span><span class=nb>></span><span class=w> </span><span class=p>(</span><span class=nb>defun</span><span class=w> </span><span class=nv>our-length</span><span class=w> </span><span class=p>(</span><span class=nv>lst</span><span class=p>)</span>
<span class=w>     </span><span class=p>(</span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nb>null</span><span class=w> </span><span class=nv>lst</span><span class=p>)</span>
<span class=w>         </span><span class=mi>0</span>
<span class=w>         </span><span class=p>(</span><span class=nb>+</span><span class=w> </span><span class=p>(</span><span class=nv>our-length</span><span class=w> </span><span class=p>(</span><span class=nb>cdr</span><span class=w> </span><span class=nv>lst</span><span class=p>))</span><span class=w> </span><span class=mi>1</span><span class=p>)))</span>
</pre></div></div><div class=section id=functions-as-objects><h3><a class=toc-backref href=#toc-entry-19>2.14. functions as objects</a></h3><p>function that takes a function as an argument is <em>apply</em><div class=highlight><pre><span></span><span class=nb>></span><span class=w> </span><span class=p>(</span><span class=nb>apply</span><span class=w> </span><span class=nf>#'</span><span class=nb>+</span><span class=w> </span><span class=o>'</span><span class=p>(</span><span class=mi>1</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=mi>3</span><span class=p>))</span>
<span class=mi>6</span>
<span class=nb>></span><span class=w> </span><span class=p>(</span><span class=nb>apply</span><span class=w> </span><span class=nf>#'</span><span class=nb>+</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=o>'</span><span class=p>(</span><span class=mi>3</span><span class=w> </span><span class=mi>4</span><span class=w> </span><span class=mi>5</span><span class=p>))</span><span class=w>  </span><span class=c1>; any number of arguments, so long as the last is a list</span>
<span class=mi>15</span>
<span class=c1>; funcall does the same thing but does not need the arguments to be</span>
<span class=nv>packaged</span><span class=w> </span><span class=nv>in</span><span class=w> </span><span class=nv>a</span><span class=w> </span><span class=nb>list</span>
<span class=nb>></span><span class=w> </span><span class=p>(</span><span class=nb>funcall</span><span class=w> </span><span class=nf>#'</span><span class=nb>+</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=mi>3</span><span class=p>)</span>
<span class=mi>6</span>

<span class=nb>></span><span class=w> </span><span class=p>(</span><span class=nb>funcall</span><span class=w> </span><span class=nf>#'</span><span class=p>(</span><span class=k>lambda</span><span class=w> </span><span class=p>(</span><span class=nv>x</span><span class=p>)</span><span class=w> </span><span class=p>(</span><span class=nb>+</span><span class=w> </span><span class=nv>x</span><span class=w> </span><span class=mi>1</span><span class=p>))</span>
<span class=w>             </span><span class=mi>1</span><span class=p>)</span>
<span class=mi>2</span>
</pre></div></div><div class=section id=types><h3><a class=toc-backref href=#toc-entry-20>2.15. types</a></h3><p>cl types from a hierachy of subtypes and supertypes. 27 is of type <em>fixnum, integer, rational, real, number, atom, and t</em>, in order of increasing generality.<div class=highlight><pre><span></span><span class=nb>></span><span class=w> </span><span class=p>(</span><span class=nb>typep</span><span class=w> </span><span class=mi>27</span><span class=w> </span><span class=ss>'integer</span><span class=p>)</span>
<span class=no>T</span>
</pre></div></div><div class=section id=looking-forward><h3><a class=toc-backref href=#toc-entry-21>2.16. looking forward</a></h3><p>So far we have barely scratched the surface of Lisp.<ul class=simple><li>interactive on toplevel<li>prefix syntax means any number of arguments<li>parentheses are not an issue, we use indentation<li>funcional programming, which avoid side-effects, is the dominant paradigm</ul></div><div class=section id=exercise><h3><a class=toc-backref href=#toc-entry-22>2.17. exercise</a></h3><ol class=arabic><li><p class=first>describe what happens when the following expressions are evaluated</p> <ul class=simple><li>(+ (- 5 1) (+ 3 7)) ; 14<li>(list 1 (+ 2 3)) ; (1 5)<li>(if (listp 1) (+ 1 2) (+ 3 4)) ; 7<li>(list (and (listp 3) t) (+ 1 2)) ; (nil 3)</ul><li><p class=first>give three distinct <em>cons</em> expressions that return (a b c)</p> <ul class=simple><li>(cons 'a '(b c))<li>(cons 'a (cons 'b '(c)))<li>I can't think of another solution...</ul><li><p class=first>using <em>car</em> and <em>cdr</em>, define a function to return the fourth element of a list</p> <div class=highlight><pre><span></span><span class=p>(</span><span class=nb>defun</span><span class=w> </span><span class=nv>my-fourth</span><span class=w> </span><span class=p>(</span><span class=nv>lst</span><span class=p>)</span>
<span class=w>   </span><span class=p>(</span><span class=nb>car</span><span class=w> </span><span class=p>(</span><span class=nb>cdr</span><span class=w> </span><span class=p>(</span><span class=nb>cdr</span><span class=w> </span><span class=p>(</span><span class=nb>cdr</span><span class=w> </span><span class=nv>lst</span><span class=p>)))))</span>
</pre></div><li><p class=first>define a function that takes two arguments and returns the greater of the two</p> <div class=highlight><pre><span></span><span class=p>(</span><span class=nb>defun</span><span class=w> </span><span class=nv>my-greater</span><span class=w> </span><span class=p>(</span><span class=nv>x</span><span class=w> </span><span class=nv>y</span><span class=p>)</span>
<span class=w>   </span><span class=p>(</span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nb>></span><span class=w> </span><span class=nv>x</span><span class=w> </span><span class=nv>y</span><span class=p>)</span>
<span class=w>       </span><span class=nv>x</span>
<span class=w>       </span><span class=nv>y</span><span class=p>))</span>
</pre></div><li><p class=first>what do these functions do</p> <div class=highlight><pre><span></span><span class=p>(</span><span class=nb>defun</span><span class=w> </span><span class=nv>enigma</span><span class=w> </span><span class=p>(</span><span class=nv>x</span><span class=p>)</span>
<span class=w>   </span><span class=p>(</span><span class=nb>and</span><span class=w> </span><span class=p>(</span><span class=nb>not</span><span class=w> </span><span class=p>(</span><span class=nb>null</span><span class=w> </span><span class=nv>x</span><span class=p>))</span>
<span class=w>        </span><span class=p>(</span><span class=nb>or</span><span class=w> </span><span class=p>(</span><span class=nb>null</span><span class=w> </span><span class=p>(</span><span class=nb>car</span><span class=w> </span><span class=nv>x</span><span class=p>))</span>
<span class=w>            </span><span class=p>(</span><span class=nv>enigma</span><span class=w> </span><span class=p>(</span><span class=nb>cdr</span><span class=w> </span><span class=nv>x</span><span class=p>)))))</span>

<span class=c1>; if nil is in x</span>
</pre></div> <div class=highlight><pre><span></span><span class=p>(</span><span class=nb>defun</span><span class=w> </span><span class=nv>mystery</span><span class=w> </span><span class=p>(</span><span class=nv>x</span><span class=w> </span><span class=nv>y</span><span class=p>)</span>
<span class=w>   </span><span class=p>(</span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nb>null</span><span class=w> </span><span class=nv>y</span><span class=p>)</span>
<span class=w>       </span><span class=no>nil</span>
<span class=w>       </span><span class=p>(</span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nb>eql</span><span class=w> </span><span class=p>(</span><span class=nb>car</span><span class=w> </span><span class=nv>y</span><span class=p>)</span><span class=w> </span><span class=nv>x</span><span class=p>)</span>
<span class=w>       </span><span class=mi>0</span>
<span class=w>       </span><span class=p>(</span><span class=k>let</span><span class=w> </span><span class=p>((</span><span class=nv>z</span><span class=w> </span><span class=p>(</span><span class=nv>mystery</span><span class=w> </span><span class=nv>x</span><span class=w> </span><span class=p>(</span><span class=nb>cdr</span><span class=w> </span><span class=nv>y</span><span class=p>))))</span>
<span class=w>            </span><span class=p>(</span><span class=nb>and</span><span class=w> </span><span class=nv>z</span><span class=w> </span><span class=p>(</span><span class=nb>+</span><span class=w> </span><span class=nv>z</span><span class=w> </span><span class=mi>1</span><span class=p>))))))</span>

<span class=c1>; count number of elements in y which differ x</span>
</pre></div><li><p class=first>what could occur in place of the <em>x</em> in each of the following exchanges</p> <ul class=simple><li>> (car (<strong>car</strong> (cdr '(a (b c) d)))) B<li>> (<strong>or</strong> 13 (/ 1 0)) 13<li>> (<strong>apply</strong> #'list 1 nil) (1)</ul><li><p class=first>using only operators introduced in this chapter, define a function that takes a list as an argument and returns true if one of its elements is a list</p> <div class=highlight><pre><span></span><span class=p>(</span><span class=nb>defun</span><span class=w> </span><span class=nv>if-have-list</span><span class=w> </span><span class=p>(</span><span class=nv>lst</span><span class=p>)</span>
<span class=w>   </span><span class=p>(</span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nb>null</span><span class=w> </span><span class=nv>lst</span><span class=p>)</span>
<span class=w>     </span><span class=no>nil</span>
<span class=w>     </span><span class=p>(</span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nb>listp</span><span class=w> </span><span class=p>(</span><span class=nb>car</span><span class=w> </span><span class=nv>lst</span><span class=p>))</span>
<span class=w>       </span><span class=no>t</span>
<span class=w>       </span><span class=p>(</span><span class=nv>if-have-list</span><span class=w> </span><span class=p>(</span><span class=nb>cdr</span><span class=w> </span><span class=nv>lst</span><span class=p>)))))</span>
</pre></div><li><p class=first>give iterative and recursive definitions of a function that</p> <ol class="arabic simple"><li>takes a positive integer and prints that many dots</ol> <div class=highlight><pre><span></span><span class=p>(</span><span class=nb>defun</span><span class=w> </span><span class=nv>print-dots-iteratively</span><span class=w> </span><span class=p>(</span><span class=nv>x</span><span class=p>)</span>
<span class=w>   </span><span class=p>(</span><span class=nb>do</span><span class=w> </span><span class=p>((</span><span class=nv>i</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>(</span><span class=nb>+</span><span class=w> </span><span class=nv>i</span><span class=w> </span><span class=mi>1</span><span class=p>)))</span>
<span class=w>       </span><span class=p>((</span><span class=nb>eql</span><span class=w> </span><span class=nv>i</span><span class=w> </span><span class=nv>x</span><span class=p>)</span><span class=w> </span><span class=ss>'done</span><span class=p>)</span>
<span class=w>       </span><span class=p>(</span><span class=nb>format</span><span class=w> </span><span class=no>t</span><span class=w> </span><span class=s>"."</span><span class=p>)</span>
<span class=w>   </span><span class=p>)</span>
<span class=p>)</span>
</pre></div> <div class=highlight><pre><span></span><span class=p>(</span><span class=nb>defun</span><span class=w> </span><span class=nv>print-dots-recursively</span><span class=w> </span><span class=p>(</span><span class=nv>x</span><span class=p>)</span>
<span class=w>   </span><span class=p>(</span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nb>eql</span><span class=w> </span><span class=nv>x</span><span class=w> </span><span class=mi>0</span><span class=p>)</span>
<span class=w>       </span><span class=ss>'done</span>
<span class=w>       </span><span class=p>(</span><span class=k>progn</span>
<span class=w>          </span><span class=p>(</span><span class=nb>format</span><span class=w> </span><span class=no>t</span><span class=w> </span><span class=s>"."</span><span class=p>)</span>
<span class=w>          </span><span class=p>(</span><span class=nv>print-dots-recursively</span><span class=w> </span><span class=p>(</span><span class=nb>-</span><span class=w> </span><span class=nv>x</span><span class=w> </span><span class=mi>1</span><span class=p>)))))</span>
</pre></div> <ol class="arabic simple" start=2><li>takes a list and returns the number of times the symbol <em>a</em> occurs in it</ol> <div class=highlight><pre><span></span><span class=p>(</span><span class=nb>defun</span><span class=w> </span><span class=nv>a-interative-counter</span><span class=w> </span><span class=p>(</span><span class=nv>lst</span><span class=p>)</span>
<span class=w>    </span><span class=p>(</span><span class=k>let</span><span class=w> </span><span class=p>((</span><span class=nb>count</span><span class=w> </span><span class=mi>0</span><span class=p>))</span>
<span class=w>       </span><span class=p>(</span><span class=nb>dolist</span><span class=w> </span><span class=p>(</span><span class=nv>obj</span><span class=w> </span><span class=nv>lst</span><span class=p>)</span>
<span class=w>          </span><span class=p>(</span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nb>eql</span><span class=w> </span><span class=nv>obj</span><span class=w> </span><span class=ss>'a</span><span class=p>)</span>
<span class=w>             </span><span class=p>(</span><span class=nb>setf</span><span class=w> </span><span class=nb>count</span><span class=w> </span><span class=p>(</span><span class=nb>+</span><span class=w> </span><span class=nb>count</span><span class=w> </span><span class=mi>1</span><span class=p>))))</span>
<span class=w>        </span><span class=nb>count</span><span class=p>))</span>
</pre></div> <div class=highlight><pre><span></span><span class=p>(</span><span class=nb>defun</span><span class=w> </span><span class=nv>a-recursive-counter</span><span class=w> </span><span class=p>(</span><span class=nv>lst</span><span class=p>)</span>
<span class=w>   </span><span class=p>()</span>
<span class=p>)</span>
</pre></div><li><p class=first>a friend is trying to write a function that returns the sum of all the non-nil elements in a list. he has written two versions of this function, and neither of them work. explain what's wrong with each, and give a correct version</p> <ol class=loweralpha><li><div class=first><div class=highlight><pre><span></span><span class=p>(</span><span class=nb>defun</span><span class=w> </span><span class=nv>summit</span><span class=w> </span><span class=p>(</span><span class=nv>lst</span><span class=p>)</span>
<span class=w>   </span><span class=p>(</span><span class=nb>remove</span><span class=w> </span><span class=no>nil</span><span class=w> </span><span class=nv>lst</span><span class=p>)</span>
<span class=w>   </span><span class=c1>; (setf lst (remove nil lst)) to update lst</span>
<span class=w>   </span><span class=p>(</span><span class=nb>apply</span><span class=w> </span><span class=nf>#'</span><span class=nb>+</span><span class=w> </span><span class=nv>lst</span><span class=p>))</span>
</pre></div></div><li><div class=first><div class=highlight><pre><span></span><span class=p>(</span><span class=nb>defun</span><span class=w> </span><span class=nv>summit</span><span class=w> </span><span class=p>(</span><span class=nv>lst</span><span class=p>)</span>
<span class=w>   </span><span class=p>(</span><span class=k>let</span><span class=w> </span><span class=p>((</span><span class=nv>x</span><span class=w> </span><span class=p>(</span><span class=nb>car</span><span class=w> </span><span class=nv>lst</span><span class=p>)))</span>
<span class=w>      </span><span class=p>(</span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nb>null</span><span class=w> </span><span class=nv>x</span><span class=p>)</span>
<span class=w>          </span><span class=c1>; I strongly doubt here goes wrong</span>
<span class=w>          </span><span class=c1>; (cdr last-element) is still nil</span>
<span class=w>          </span><span class=c1>; so this is an infinite loop</span>
<span class=w>          </span><span class=p>(</span><span class=nv>summit</span><span class=w> </span><span class=p>(</span><span class=nb>cdr</span><span class=w> </span><span class=nv>lst</span><span class=p>))</span>
<span class=w>          </span><span class=p>(</span><span class=nb>+</span><span class=w> </span><span class=nv>x</span><span class=w> </span><span class=p>(</span><span class=nv>summit</span><span class=w> </span><span class=p>(</span><span class=nb>cdr</span><span class=w> </span><span class=nv>lst</span><span class=p>))))))</span>
</pre></div></div></ol></ol></div></div><div class=section id=lists><h2><a class=toc-backref href=#toc-entry-23>3. Lists</a></h2><div class=section id=conses><h3><a class=toc-backref href=#toc-entry-24>3.1. conses</a></h3><div class=highlight><pre><span></span><span class=nb>></span><span class=w> </span><span class=p>(</span><span class=nb>setf</span><span class=w> </span><span class=nv>x</span><span class=w> </span><span class=p>(</span><span class=nb>cons</span><span class=w> </span><span class=ss>'a</span><span class=w> </span><span class=no>nil</span><span class=p>))</span>
<span class=nb>></span><span class=w> </span><span class=p>(</span><span class=nb>setf</span><span class=w> </span><span class=nv>y</span><span class=w> </span><span class=p>(</span><span class=nb>list</span><span class=w> </span><span class=ss>'a</span><span class=w> </span><span class=ss>'b</span><span class=w> </span><span class=ss>'c</span><span class=p>))</span><span class=w>  </span><span class=c1>; flat list</span>
<span class=nb>></span><span class=w> </span><span class=p>(</span><span class=nb>setf</span><span class=w> </span><span class=nv>z</span><span class=w> </span><span class=p>(</span><span class=nb>list</span><span class=w> </span><span class=ss>'a</span><span class=w> </span><span class=p>(</span><span class=nb>list</span><span class=w> </span><span class=ss>'b</span><span class=w> </span><span class=ss>'c</span><span class=p>)</span><span class=w> </span><span class=ss>'d</span><span class=p>))</span><span class=w>  </span><span class=c1>; nested list</span>

<span class=p>(</span><span class=nb>defun</span><span class=w> </span><span class=nv>my-listp</span><span class=w> </span><span class=p>(</span><span class=nv>x</span><span class=p>)</span>
<span class=w>    </span><span class=p>(</span><span class=nb>or</span><span class=w> </span><span class=p>(</span><span class=nb>null</span><span class=w> </span><span class=nv>x</span><span class=p>)</span><span class=w> </span><span class=p>(</span><span class=nb>consp</span><span class=w> </span><span class=nv>x</span><span class=p>)))</span>

<span class=p>(</span><span class=nb>defun</span><span class=w> </span><span class=nv>my-atom</span><span class=w> </span><span class=p>(</span><span class=nv>x</span><span class=p>)</span>
<span class=w>    </span><span class=p>(</span><span class=nb>not</span><span class=w> </span><span class=p>(</span><span class=nb>consp</span><span class=w> </span><span class=nv>x</span><span class=p>)))</span>
</pre></div><p><em>nil</em> is both an <em>atom</em> and <em>list</em></div><div class=section id=equality><h3><a class=toc-backref href=#toc-entry-25>3.2. equality</a></h3><p>calling <em>cons</em> makes lisp allocate a piece of memory for two pointers, so calling <em>cons</em> twice generates two distinctly different objects.<div class=highlight><pre><span></span><span class=nb>></span><span class=w> </span><span class=p>(</span><span class=nb>eql</span><span class=w> </span><span class=p>(</span><span class=nb>cons</span><span class=w> </span><span class=ss>'a</span><span class=w> </span><span class=no>nil</span><span class=p>)</span><span class=w> </span><span class=p>(</span><span class=nb>cons</span><span class=w> </span><span class=ss>'a</span><span class=w> </span><span class=no>nil</span><span class=p>))</span>
<span class=no>NIL</span>
</pre></div><p><em>eql</em> returns true only if <strong>the same object</strong>, and <em>equal</em> only needs printed result being same.</div></div>